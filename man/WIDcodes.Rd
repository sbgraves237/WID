% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/WIDcodes.R
\name{WIDcodes}
\alias{WIDcodes}
\title{WIDcodes}
\usage{
WIDcodes(code, data, meta, cols2return)
}
\arguments{
\item{code}{name of a column of \code{data} for which matching information in
\code{meta} is desired. If \code{grep(code, names(meta))} finds nothing, \code{WIDcodes}
throws an error. Otherwise it returns the number of matches for each level
of \code{code} in \code{data} followed by the corresponding information in \code{meta}.
If \code{length(grep(code, names(meta)))} > 1, \code{WIDcodes} returns the
corresponding content of the matching columns of \code{meta}.

In particular,
\itemize{
\item \code{WIDcode('age', ...)} returns matching columns of \code{shortage} and \code{longage}.
\item \code{WIDcode('pop', ...)} returns matching columns of \code{shortpop} and \code{longpop}.
\item \code{WIDcode('country', ...)} returns matching columns of \code{countryname}.
}

If \code{length(grep(code, names(meta)))} = 1, \code{WIDcodes} returns the the
contents of corresponding colums of \code{meta} except those including \code{age},
\code{pop}, and \code{country} and except the last two columns (\code{extrapolation} and
\code{data_points}), which are often missing.}

\item{data}{a \code{data.frame} returned by
\code{read.csv2('WID_data_XX.csv')}, where \code{XX} is a 2-character ISO country or a
5- or 6-character ISO code for a region within a country.}

\item{meta}{a \code{data.frame} returned by
\code{read.csv2('WID_metadata_XX.csv')}, where \code{XX} is a 2-character ISO country
or a 5- or 6-character ISO code for a region within a country.}

\item{cols2return}{columns of \code{meta} to return. If \code{missing}, the algorithm
attempts to infer columns to return, as discussed with \code{code}, above. This
is only needed if the matching content in the last two columns of \code{meta} are
desired.

NOTE: \code{WIDcode} assumes that \code{XX} for \code{data} matches that of \code{metadata} but
does nothing to check this assumption.}
}
\value{
a \code{\link{data.frame}} with the values of columns of \code{meta} that
correspond to levels of \code{data[, code]} if only one value for that varable is
found, If more than one level of a selected column of \code{meta} are found,
those values are retained not as a column of the \code{data.frame} but in a
\code{nonunique} attribute, which is a list with names of the levels of \code{code}
(and therefore the same length as the number of rows of the \code{data.frame})
with all the levels of the non-unique column(s) of \code{meta}. The \code{rownames}
and the first column of the \code{data.frame} are the names of the levels of
\code{data[, code]}. The second column is the counts from \code{table(data[, code])}.
The remaining columns are the nonunique values found in the selected
column(s) of \code{meta}.
}
\description{
Extract definitions from a \verb{_metadata_} file for variables in a
corresponding \verb{_data_} file in the
\href{https://wid.world/}{World Inequalty Database (WID)}.
}
\examples{
ageCodes <- WIDcodes('age', DE_BYdat, DE_BYmeta)
popCodes <- WIDcodes('pop', DE_BYdat, DE_BYmeta)
varCodes <- WIDcodes('variable', DE_BYdat, DE_BYmeta)
ageExtrap <- WIDcodes('age', DE_BYdat, DE_BYmeta, 
                c('extrapolation', 'data_points'))
# ageExtrap is a list, 
# because DE_BYmeta[, c('extrapolation', 'data_points')] are all NAs. 

# to get typeCodes, we must first add it to both DE_BYdat and DE_BYmeta
DE_BYdat$type <- substring(DE_BYdat$variable, 1, 1)
DE_BYmeta$type <- substring(DE_BYmeta$variable, 1, 1)
typeCodes <- WIDcodes('type', DE_BYdat, DE_BYmeta)

# Let's also get concept 
DE_BYdat$concept <- substring(DE_BYdat$variable, 2, 6)
DE_BYmeta$concept <- substring(DE_BYmeta$variable, 2, 6)
conceptCodes <- WIDcodes('concept', DE_BYdat, DE_BYmeta)

\dontrun{
WIDcodes('percentile', DE_BYdat, DE_BYmeta)
# throws an error, because 'percentile' is not in names(DE_BYmeta)
}

}
\keyword{manip}
